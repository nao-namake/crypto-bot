"""
„Ç®„É©„ÉºËÄêÊÄßÂº∑Âåñ„Ç∑„Çπ„ÉÜ„É† - Phase H.8.3
ÂåÖÊã¨ÁöÑ„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Éª„É™„Ç´„Éê„É™„Éª„Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„ÉºÊ©üËÉΩ
"""

import logging
import threading
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Any, Callable, Dict, List, Optional

logger = logging.getLogger(__name__)


@dataclass
class ErrorRecord:
    """„Ç®„É©„ÉºË®òÈå≤"""

    timestamp: datetime
    error_type: str
    error_message: str
    component: str
    severity: str
    recovery_attempted: bool = False
    recovery_successful: bool = False


@dataclass
class CircuitBreakerState:
    """„Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„ÉºÁä∂ÊÖã"""

    component: str
    state: str = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
    failure_count: int = 0
    last_failure_time: Optional[datetime] = None
    last_success_time: Optional[datetime] = None
    failure_threshold: int = 5
    recovery_timeout: int = 300  # 5ÂàÜ

    def reset(self):
        """Áä∂ÊÖã„É™„Çª„ÉÉ„Éà"""
        self.state = "CLOSED"
        self.failure_count = 0
        self.last_failure_time = None


class ErrorResilienceManager:
    """„Ç®„É©„ÉºËÄêÊÄßÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†"""

    def __init__(self, max_error_history: int = 1000):
        self.error_history: List[ErrorRecord] = []
        self.circuit_breakers: Dict[str, CircuitBreakerState] = {}
        self.max_error_history = max_error_history
        self.lock = threading.Lock()

        # Phase H.8.3: Á∑äÊÄ•ÂÅúÊ≠¢„Éï„É©„Ç∞
        self.emergency_stop = False
        self.critical_error_count = 0
        self.critical_error_threshold = 3

        logger.info("üõ°Ô∏è [PHASE-H8.3] Error Resilience Manager initialized")

    def record_error(
        self,
        component: str,
        error_type: str,
        error_message: str,
        severity: str = "WARNING",
    ) -> None:
        """„Ç®„É©„ÉºË®òÈå≤"""
        with self.lock:
            error_record = ErrorRecord(
                timestamp=datetime.now(),
                error_type=error_type,
                error_message=error_message,
                component=component,
                severity=severity,
            )

            self.error_history.append(error_record)

            # Â±•Ê≠¥„Çµ„Ç§„Ç∫Âà∂Èôê
            if len(self.error_history) > self.max_error_history:
                self.error_history = self.error_history[-self.max_error_history :]

            # CRITICAL „Ç®„É©„Éº„ÅÆÂ†¥Âêà
            if severity == "CRITICAL":
                self.critical_error_count += 1
                logger.critical(
                    f"üö® [RESILIENCE] CRITICAL error recorded: {component} - {error_type}"
                )

                # Á∑äÊÄ•ÂÅúÊ≠¢Âà§ÂÆö
                if self.critical_error_count >= self.critical_error_threshold:
                    self.emergency_stop = True
                    logger.critical(
                        f"üö® [RESILIENCE] EMERGENCY STOP activated: {self.critical_error_count} critical errors"
                    )

            # „Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„ÉºÊõ¥Êñ∞
            self._update_circuit_breaker(component, False)

            logger.warning(
                f"‚ö†Ô∏è [RESILIENCE] Error recorded: {component} - {error_type} - {severity}"
            )

    def record_success(self, component: str) -> None:
        """ÊàêÂäüË®òÈå≤Ôºà„Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„ÉºÂõûÂæ©Áî®Ôºâ"""
        with self.lock:
            self._update_circuit_breaker(component, True)

            # CRITICAL „Ç®„É©„Éº„Ç´„Ç¶„É≥„Éà„ÅÆ„É™„Çª„ÉÉ„ÉàÊù°‰ª∂
            if component in ["data_fetcher", "ml_strategy", "trading_core"]:
                if self.critical_error_count > 0:
                    self.critical_error_count = max(0, self.critical_error_count - 1)
                    logger.info(
                        f"‚úÖ [RESILIENCE] Critical error count reduced: {self.critical_error_count}"
                    )

    def _update_circuit_breaker(self, component: str, success: bool) -> None:
        """„Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„ÉºÁä∂ÊÖãÊõ¥Êñ∞"""
        if component not in self.circuit_breakers:
            self.circuit_breakers[component] = CircuitBreakerState(component=component)

        breaker = self.circuit_breakers[component]
        current_time = datetime.now()

        if success:
            breaker.last_success_time = current_time
            if breaker.state == "HALF_OPEN":
                # HALF_OPENÁä∂ÊÖã„ÅßÊàêÂäü ‚Üí CLOSEDÁä∂ÊÖã„Å´Âæ©Â∏∞
                breaker.reset()
                logger.info(f"‚úÖ [RESILIENCE] Circuit breaker RECOVERED: {component}")
            elif breaker.state == "CLOSED":
                # ÊàêÂäüÊôÇ„ÅØÂ§±Êïó„Ç´„Ç¶„É≥„Éà„ÇíÊ∏õ„Çâ„Åô
                breaker.failure_count = max(0, breaker.failure_count - 1)
        else:
            breaker.failure_count += 1
            breaker.last_failure_time = current_time

            if (
                breaker.state == "CLOSED"
                and breaker.failure_count >= breaker.failure_threshold
            ):
                # Â§±ÊïóÈñæÂÄ§Ë∂ÖÈÅé ‚Üí OPENÁä∂ÊÖã
                breaker.state = "OPEN"
                logger.critical(f"üö® [RESILIENCE] Circuit breaker OPENED: {component}")
            elif breaker.state == "HALF_OPEN":
                # HALF_OPENÁä∂ÊÖã„ÅßÂ§±Êïó ‚Üí OPENÁä∂ÊÖã„Å´Êàª„Çã
                breaker.state = "OPEN"
                logger.warning(f"‚ö†Ô∏è [RESILIENCE] Circuit breaker REOPENED: {component}")

    def is_circuit_open(self, component: str) -> bool:
        """„Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„Éº„ÅåOPENÁä∂ÊÖã„Åã„ÉÅ„Çß„ÉÉ„ÇØ"""
        if component not in self.circuit_breakers:
            return False

        breaker = self.circuit_breakers[component]
        current_time = datetime.now()

        if breaker.state == "OPEN":
            # „É™„Ç´„Éê„É™„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÂæå„ÅØHALF_OPENÁä∂ÊÖã„Å´
            if (
                breaker.last_failure_time
                and current_time - breaker.last_failure_time
                > timedelta(seconds=breaker.recovery_timeout)
            ):
                breaker.state = "HALF_OPEN"
                logger.info(f"üîÑ [RESILIENCE] Circuit breaker HALF_OPEN: {component}")
                return False
            return True

        return False

    def can_proceed(self, component: str) -> bool:
        """„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅåÂÆüË°åÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ"""
        if self.emergency_stop:
            return False
        return not self.is_circuit_open(component)

    def get_error_summary(self, hours: int = 24) -> Dict[str, Any]:
        """„Ç®„É©„Éº„Çµ„Éû„É™„ÉºÂèñÂæó"""
        with self.lock:
            cutoff_time = datetime.now() - timedelta(hours=hours)
            recent_errors = [e for e in self.error_history if e.timestamp > cutoff_time]

            summary = {
                "total_errors": len(recent_errors),
                "critical_errors": len(
                    [e for e in recent_errors if e.severity == "CRITICAL"]
                ),
                "warning_errors": len(
                    [e for e in recent_errors if e.severity == "WARNING"]
                ),
                "error_by_component": {},
                "error_by_type": {},
                "circuit_breaker_states": {},
                "emergency_stop": self.emergency_stop,
                "critical_error_count": self.critical_error_count,
            }

            # „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÂà•„Ç®„É©„ÉºÈõÜË®à
            for error in recent_errors:
                comp = error.component
                summary["error_by_component"][comp] = (
                    summary["error_by_component"].get(comp, 0) + 1
                )

                err_type = error.error_type
                summary["error_by_type"][err_type] = (
                    summary["error_by_type"].get(err_type, 0) + 1
                )

            # „Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„ÉºÁä∂ÊÖã
            for component, breaker in self.circuit_breakers.items():
                summary["circuit_breaker_states"][component] = {
                    "state": breaker.state,
                    "failure_count": breaker.failure_count,
                    "last_failure": (
                        breaker.last_failure_time.isoformat()
                        if breaker.last_failure_time
                        else None
                    ),
                }

            return summary

    def force_recovery(self, component: str) -> bool:
        """Âº∑Âà∂„É™„Ç´„Éê„É™"""
        with self.lock:
            if component in self.circuit_breakers:
                self.circuit_breakers[component].reset()
                logger.info(f"üîÑ [RESILIENCE] Forced recovery for: {component}")
                return True
            return False

    def reset_emergency_stop(self) -> None:
        """Á∑äÊÄ•ÂÅúÊ≠¢„É™„Çª„ÉÉ„Éà"""
        with self.lock:
            self.emergency_stop = False
            self.critical_error_count = 0
            logger.info("üîÑ [RESILIENCE] Emergency stop RESET")

    def with_error_handling(self, component: str, operation_name: str):
        """„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞‰ªò„Åç„Éá„Ç≥„É¨„Éº„Çø„Éº"""

        def decorator(func: Callable):
            def wrapper(*args, **kwargs):
                if not self.can_proceed(component):
                    raise RuntimeError(f"Circuit breaker open for {component}")

                try:
                    result = func(*args, **kwargs)
                    self.record_success(component)
                    return result
                except Exception as e:
                    self.record_error(
                        component=component,
                        error_type=type(e).__name__,
                        error_message=str(e),
                        severity=(
                            "CRITICAL"
                            if isinstance(e, (ConnectionError, TimeoutError))
                            else "WARNING"
                        ),
                    )
                    raise

            return wrapper

        return decorator


# „Ç∞„É≠„Éº„Éê„É´„Ç§„É≥„Çπ„Çø„É≥„Çπ
_global_resilience_manager: Optional[ErrorResilienceManager] = None


def get_resilience_manager() -> ErrorResilienceManager:
    """„Ç∞„É≠„Éº„Éê„É´„É¨„Ç∏„É™„Ç®„É≥„Çπ„Éû„Éç„Éº„Ç∏„É£„ÉºÂèñÂæó"""
    global _global_resilience_manager
    if _global_resilience_manager is None:
        _global_resilience_manager = ErrorResilienceManager()
    return _global_resilience_manager


def with_resilience(component: str, operation_name: str = ""):
    """„É¨„Ç∏„É™„Ç®„É≥„Çπ‰ªò„Åç„Éá„Ç≥„É¨„Éº„Çø„Éº"""
    manager = get_resilience_manager()
    return manager.with_error_handling(component, operation_name)


# ‰ΩøÁî®‰æã
class ResilientDataFetcher:
    """„É¨„Ç∏„É™„Ç®„É≥„Éà‰ªò„Åç„Éá„Éº„Çø„Éï„Çß„ÉÉ„ÉÅ„É£„Éº"""

    def __init__(self, base_fetcher):
        self.base_fetcher = base_fetcher
        self.resilience = get_resilience_manager()

    @with_resilience("data_fetcher", "fetch_price_data")
    def fetch_price_data(self, *args, **kwargs):
        """„É¨„Ç∏„É™„Ç®„É≥„Éà‰ªò„Åç„Éá„Éº„ÇøÂèñÂæó"""
        return self.base_fetcher.get_price_df(*args, **kwargs)

    @with_resilience("data_fetcher", "fetch_balance")
    def fetch_balance(self, *args, **kwargs):
        """„É¨„Ç∏„É™„Ç®„É≥„Éà‰ªò„ÅçÊÆãÈ´òÂèñÂæó"""
        return self.base_fetcher.fetch_balance(*args, **kwargs)


def get_system_health_status() -> Dict[str, Any]:
    """„Ç∑„Çπ„ÉÜ„É†„Éò„É´„ÇπÁä∂ÊÖãÂèñÂæó"""
    manager = get_resilience_manager()

    summary = manager.get_error_summary(hours=1)  # ÈÅéÂéª1ÊôÇÈñì

    health_status = {
        "overall_health": "HEALTHY",
        "emergency_stop": summary["emergency_stop"],
        "error_summary": summary,
        "recommendations": [],
    }

    # „Éò„É´„ÇπÂà§ÂÆö
    if summary["emergency_stop"]:
        health_status["overall_health"] = "CRITICAL"
        health_status["recommendations"].append("Á∑äÊÄ•ÂÅúÊ≠¢‰∏≠ - ÊâãÂãï„É™„Çª„ÉÉ„Éà„ÅåÂøÖË¶Å")
    elif summary["critical_errors"] > 0:
        health_status["overall_health"] = "WARNING"
        health_status["recommendations"].append("CRITICAL „Ç®„É©„Éº„ÅÇ„Çä - Ë™øÊüª„ÅåÂøÖË¶Å")
    elif summary["total_errors"] > 10:
        health_status["overall_health"] = "WARNING"
        health_status["recommendations"].append("„Ç®„É©„ÉºÂ§öÁô∫ - „Ç∑„Çπ„ÉÜ„É†Áõ£Ë¶ñÂº∑ÂåñÊé®Â•®")

    # „Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„ÉºÁ¢∫Ë™ç
    open_breakers = [
        comp
        for comp, state in summary["circuit_breaker_states"].items()
        if state["state"] == "OPEN"
    ]
    if open_breakers:
        health_status["overall_health"] = "WARNING"
        health_status["recommendations"].append(
            f"„Çµ„Éº„Ç≠„ÉÉ„Éà„Éñ„É¨„Éº„Ç´„ÉºOPEN: {', '.join(open_breakers)}"
        )

    return health_status
