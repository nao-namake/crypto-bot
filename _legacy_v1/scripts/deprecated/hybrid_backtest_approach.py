#!/usr/bin/env python3
"""
HybridBacktestEngine - Phase 2.1 97ÁâπÂæ¥ÈáèMLÁµ±ÂêàÁâà
bitbank-laboÊñπÂºè„ÅÆËªΩÈáèÊÄß + 97ÁâπÂæ¥ÈáèMLÁµ±Âêà

Phase 2„Ç¢„Éó„É≠„Éº„ÉÅ:
1. Phase A: ËªΩÈáèÁâàÔºà3ÂàÜ‰ª•ÂÜÖÔºâ- Âü∫Êú¨Âãï‰ΩúÁ¢∫Ë™ç„Éª15ÁâπÂæ¥Èáè
2. Phase B: MLÁµ±ÂêàÁâàÔºà7ÂàÜ‰ª•ÂÜÖÔºâ- 97ÁâπÂæ¥ÈáèÂÆåÂÖ®Áâà + „Ç¢„É≥„Çµ„É≥„Éñ„É´ML
3. Phase C: È´òÈÄü„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÔºà10ÂàÜ‰ª•ÂÜÖÔºâ- production_97_backtest.ymlÂØæÂøú

97ÁâπÂæ¥ÈáèÂÆåÂÖ®ÂØæÂøú„ÉªÂ§ñÈÉ®„Éá„Éº„ÇøÁÑ°Âäπ„ÉªCSVÈ´òÈÄüÂá¶ÁêÜÊúÄÈÅ©Âåñ
"""

import logging
import pickle
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

import numpy as np
import pandas as pd
import yaml

# „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É´„Éº„Éà„Çí„Éë„Çπ„Å´ËøΩÂä†
sys.path.append(str(Path(__file__).parent.parent))

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# 97ÁâπÂæ¥Èáè„É™„Çπ„ÉàÔºàproduction.ymlÊ∫ñÊã†Ôºâ
FEATURE_97_LIST = [
    "close_lag_1",
    "close_lag_3",
    "volume_lag_1",
    "volume_lag_4",
    "volume_lag_5",
    "returns_1",
    "returns_2",
    "returns_3",
    "returns_5",
    "returns_10",
    "ema_5",
    "ema_10",
    "ema_20",
    "ema_50",
    "ema_100",
    "ema_200",
    "price_position_20",
    "price_position_50",
    "price_vs_sma20",
    "bb_position",
    "intraday_position",
    "bb_upper",
    "bb_middle",
    "bb_lower",
    "bb_width",
    "bb_squeeze",
    "rsi_14",
    "rsi_oversold",
    "rsi_overbought",
    "macd",
    "macd_signal",
    "macd_hist",
    "macd_cross_up",
    "macd_cross_down",
    "stoch_k",
    "stoch_d",
    "stoch_oversold",
    "stoch_overbought",
    "atr_14",
    "volatility_20",
    "volume_sma_20",
    "volume_ratio",
    "volume_trend",
    "vwap",
    "vwap_distance",
    "obv",
    "obv_sma",
    "cmf",
    "mfi",
    "ad_line",
    "adx_14",
    "plus_di",
    "minus_di",
    "trend_strength",
    "trend_direction",
    "cci_20",
    "williams_r",
    "ultimate_oscillator",
    "momentum_14",
    "support_distance",
    "resistance_distance",
    "support_strength",
    "volume_breakout",
    "price_breakout_up",
    "price_breakout_down",
    "doji",
    "hammer",
    "engulfing",
    "pinbar",
    "zscore",
    "close_std_10",
    "hour",
    "day_of_week",
    "is_weekend",
    "is_asian_session",
    "is_us_session",
    "roc_10",
    "roc_20",
    "trix",
    "mass_index",
    "keltner_upper",
    "keltner_lower",
    "donchian_upper",
    "donchian_lower",
    "ichimoku_conv",
    "ichimoku_base",
    "price_efficiency",
    "trend_consistency",
    "volume_price_correlation",
    "volatility_regime",
    "momentum_quality",
    "market_phase",
]


class HybridBacktest:
    """
    HybridBacktestEngine - Phase 2.1 97ÁâπÂæ¥ÈáèMLÁµ±ÂêàÁâà
    Phase A: ËªΩÈáèÁâàÔºà15ÁâπÂæ¥ÈáèÔºâ
    Phase B: MLÁµ±ÂêàÁâàÔºà97ÁâπÂæ¥ÈáèÂÆåÂÖ®ÁâàÔºâ
    Phase C: È´òÈÄü„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÔºàproduction_97_backtest.ymlÂØæÂøúÔºâ
    """

    def __init__(
        self, phase="B", config_path=None, initial_balance=10000, commission=0.0012
    ):
        self.phase = phase
        self.initial_balance = initial_balance
        self.balance = initial_balance
        self.commission = commission
        self.position = 0
        self.entry_price = 0
        self.trades = []
        self.ml_model = None
        self.config = None

        # Ë®≠ÂÆö„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø
        if config_path:
            self.load_config(config_path)

        logger.info(f"üöÄ HybridBacktest Phase {phase} initialized - 97ÁâπÂæ¥ÈáèÂØæÂøúÁâà")

    def load_config(self, config_path: str) -> bool:
        """Ë®≠ÂÆö„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„ÅøÔºàproduction_97_backtest.ymlÂØæÂøúÔºâ"""
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                self.config = yaml.safe_load(f)
            logger.info(f"‚úÖ Config loaded: {config_path}")
            return True
        except Exception as e:
            logger.error(f"‚ùå Config load failed: {e}")
            return False

    def load_ml_model(self):
        """ML„É¢„Éá„É´Ë™≠„ÅøËæº„ÅøÔºàPhase B„ÉªCÁî®Ôºâ"""
        if self.phase in ["B", "C"]:
            try:
                model_path = Path("models/production/xgb_97_features.pkl")
                if model_path.exists():
                    with open(model_path, "rb") as f:
                        self.ml_model = pickle.load(f)
                    logger.info("ML model loaded successfully")
                    return True
                else:
                    logger.warning("ML model not found")
                    return False
            except Exception as e:
                logger.error(f"Failed to load ML model: {e}")
                return False
        return True

    def add_basic_features(self, df):
        """Phase A: Âü∫Êú¨ÁâπÂæ¥Èáè„ÅÆ„ÅøÔºàÈ´òÈÄüÔºâ"""
        logger.info("Adding basic features (Phase A)...")

        # Âü∫Êú¨ÁöÑ„Å™ÁßªÂãïÂπ≥Âùá„ÉªRSI„ÉªMACD
        df["sma_20"] = df["close"].rolling(20).mean()
        df["rsi"] = self.calculate_rsi(df["close"], 14)
        df["macd"], df["macd_signal"] = self.calculate_macd(df["close"])

        # „Ç∑„É≥„Éó„É´„Å™„Éà„É¨„É≥„Éâ„Éª„Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£
        df["price_change"] = df["close"].pct_change()
        df["volatility"] = df["price_change"].rolling(20).std()
        df["trend"] = np.where(df["close"] > df["sma_20"], 1, -1)

        logger.info(
            f"Added {len([c for c in df.columns if c not in ['open','high','low','close','volume']])} basic features"
        )
        return df

    def add_97_features(self, df):
        """Phase B: 97ÁâπÂæ¥ÈáèÂÆåÂÖ®ÁâàÁîüÊàêÔºàproduction.ymlÊ∫ñÊã†Ôºâ"""
        if self.phase not in ["B", "C"]:
            return df

        logger.info("üîß Adding 97 features (Phase B - Complete ML Integration)...")
        start_time = time.time()

        # 1. Lag Features
        df["close_lag_1"] = df["close"].shift(1)
        df["close_lag_3"] = df["close"].shift(3)
        df["volume_lag_1"] = df["volume"].shift(1)
        df["volume_lag_4"] = df["volume"].shift(4)
        df["volume_lag_5"] = df["volume"].shift(5)

        # 2. Returns Features
        for period in [1, 2, 3, 5, 10]:
            df[f"returns_{period}"] = df["close"].pct_change(period)

        # 3. EMA Features
        for period in [5, 10, 20, 50, 100, 200]:
            df[f"ema_{period}"] = df["close"].ewm(span=period).mean()

        # 4. Price Position Features
        df["price_position_20"] = (df["close"] - df["close"].rolling(20).min()) / (
            df["close"].rolling(20).max() - df["close"].rolling(20).min()
        )
        df["price_position_50"] = (df["close"] - df["close"].rolling(50).min()) / (
            df["close"].rolling(50).max() - df["close"].rolling(50).min()
        )

        # SMA for comparison
        sma_20 = df["close"].rolling(20).mean()
        df["price_vs_sma20"] = (df["close"] - sma_20) / sma_20

        # 5. Bollinger Bands
        bb_upper, bb_lower = self.calculate_bollinger_bands(df["close"])
        df["bb_upper"] = bb_upper
        df["bb_middle"] = sma_20
        df["bb_lower"] = bb_lower
        df["bb_width"] = (bb_upper - bb_lower) / sma_20
        df["bb_position"] = (df["close"] - bb_lower) / (bb_upper - bb_lower)
        df["bb_squeeze"] = df["bb_width"] < df["bb_width"].rolling(20).mean() * 0.8

        # Intraday position
        df["intraday_position"] = (df["close"] - df["low"]) / (df["high"] - df["low"])

        # 6. RSI Features
        df["rsi_14"] = self.calculate_rsi(df["close"], 14)
        df["rsi_oversold"] = df["rsi_14"] < 30
        df["rsi_overbought"] = df["rsi_14"] > 70

        # 7. MACD Features
        df["macd"], df["macd_signal"] = self.calculate_macd(df["close"])
        df["macd_hist"] = df["macd"] - df["macd_signal"]
        df["macd_cross_up"] = (df["macd"] > df["macd_signal"]) & (
            df["macd"].shift(1) <= df["macd_signal"].shift(1)
        )
        df["macd_cross_down"] = (df["macd"] < df["macd_signal"]) & (
            df["macd"].shift(1) >= df["macd_signal"].shift(1)
        )

        # 8. Stochastic Features
        df["stoch_k"], df["stoch_d"] = self.calculate_stochastic(df)
        df["stoch_oversold"] = df["stoch_k"] < 20
        df["stoch_overbought"] = df["stoch_k"] > 80

        # 9. Volatility Features
        df["atr_14"] = self.calculate_atr(df, 14)
        df["volatility_20"] = df["close"].pct_change().rolling(20).std()

        # 10. Volume Features
        df["volume_sma_20"] = df["volume"].rolling(20).mean()
        df["volume_ratio"] = df["volume"] / df["volume_sma_20"]
        df["volume_trend"] = df["volume_sma_20"] > df["volume_sma_20"].shift(5)

        # 11. VWAP Features
        df["vwap"] = (df["close"] * df["volume"]).cumsum() / df["volume"].cumsum()
        df["vwap_distance"] = (df["close"] - df["vwap"]) / df["vwap"]

        # 12. Volume Indicators
        df["obv"] = (
            df["volume"] * np.where(df["close"] > df["close"].shift(1), 1, -1)
        ).cumsum()
        df["obv_sma"] = df["obv"].rolling(20).mean()
        df["cmf"] = self.calculate_cmf(df)
        df["mfi"] = self.calculate_mfi(df)
        df["ad_line"] = self.calculate_ad_line(df)

        # 13. Trend Indicators
        df["adx_14"], df["plus_di"], df["minus_di"] = self.calculate_adx(df, 14)
        df["trend_strength"] = df["adx_14"] > 25
        df["trend_direction"] = np.where(df["plus_di"] > df["minus_di"], 1, -1)

        # 14. Oscillators
        df["cci_20"] = self.calculate_cci(df, 20)
        df["williams_r"] = self.calculate_williams_r(df, 14)
        df["ultimate_oscillator"] = self.calculate_ultimate_oscillator(df)
        df["momentum_14"] = df["close"] / df["close"].shift(14) - 1

        # 15. Support/Resistance
        df["support_distance"] = self.calculate_support_distance(df)
        df["resistance_distance"] = self.calculate_resistance_distance(df)
        df["support_strength"] = self.calculate_support_strength(df)

        # 16. Breakout Features
        df["volume_breakout"] = df["volume"] > df["volume"].rolling(20).mean() * 2
        df["price_breakout_up"] = df["close"] > df["close"].rolling(20).max().shift(1)
        df["price_breakout_down"] = df["close"] < df["close"].rolling(20).min().shift(1)

        # 17. Candlestick Patterns (simplified)
        df["doji"] = self.detect_doji(df)
        df["hammer"] = self.detect_hammer(df)
        df["engulfing"] = self.detect_engulfing(df)
        df["pinbar"] = self.detect_pinbar(df)

        # 18. Statistical Features
        df["zscore"] = (df["close"] - df["close"].rolling(20).mean()) / df[
            "close"
        ].rolling(20).std()
        df["close_std_10"] = df["close"].rolling(10).std()

        # 19. Time Features
        df["hour"] = df.index.hour if hasattr(df.index, "hour") else 12
        df["day_of_week"] = df.index.dayofweek if hasattr(df.index, "dayofweek") else 1
        df["is_weekend"] = df["day_of_week"] >= 5
        df["is_asian_session"] = (df["hour"] >= 0) & (df["hour"] < 8)
        df["is_us_session"] = (df["hour"] >= 13) & (df["hour"] < 22)

        # 20. Additional Technical Indicators
        for period in [10, 20]:
            df[f"roc_{period}"] = (
                (df["close"] - df["close"].shift(period)) / df["close"].shift(period)
            ) * 100

        df["trix"] = self.calculate_trix(df)
        df["mass_index"] = self.calculate_mass_index(df)

        # 21. Channel Indicators
        df["keltner_upper"], df["keltner_lower"] = self.calculate_keltner_channels(df)
        df["donchian_upper"] = df["high"].rolling(20).max()
        df["donchian_lower"] = df["low"].rolling(20).min()

        # 22. Ichimoku Features (simplified)
        df["ichimoku_conv"] = (
            df["high"].rolling(9).max() + df["low"].rolling(9).min()
        ) / 2
        df["ichimoku_base"] = (
            df["high"].rolling(26).max() + df["low"].rolling(26).min()
        ) / 2

        # 23. Advanced Features
        df["price_efficiency"] = self.calculate_price_efficiency(df)
        df["trend_consistency"] = self.calculate_trend_consistency(df)
        df["volume_price_correlation"] = self.calculate_volume_price_correlation(df)
        df["volatility_regime"] = (
            df["volatility_20"] > df["volatility_20"].rolling(50).mean()
        )
        df["momentum_quality"] = self.calculate_momentum_quality(df)
        df["market_phase"] = self.calculate_market_phase(df)

        # NaNÂÄ§Âá¶ÁêÜ
        df = df.fillna(method="ffill").fillna(0)

        execution_time = time.time() - start_time
        logger.info(
            f"‚úÖ 97 features added in {execution_time:.2f}s, total columns: {df.shape[1]}"
        )

        return df

    def calculate_rsi(self, prices, period=14):
        """RSIË®àÁÆó"""
        delta = prices.diff()
        gain = delta.where(delta > 0, 0).rolling(period).mean()
        loss = -delta.where(delta < 0, 0).rolling(period).mean()
        rs = gain / loss
        return 100 - (100 / (1 + rs))

    def calculate_macd(self, prices):
        """MACDË®àÁÆó"""
        ema12 = prices.ewm(span=12).mean()
        ema26 = prices.ewm(span=26).mean()
        macd = ema12 - ema26
        signal = macd.ewm(span=9).mean()
        return macd, signal

    def calculate_bollinger_bands(self, prices, period=20, std_dev=2):
        """„Éú„É™„É≥„Ç∏„É£„Éº„Éê„É≥„ÉâË®àÁÆó"""
        sma = prices.rolling(period).mean()
        std = prices.rolling(period).std()
        upper = sma + (std * std_dev)
        lower = sma - (std * std_dev)
        return upper, lower

    def calculate_atr(self, df, period=14):
        """ATRË®àÁÆó"""
        high_low = df["high"] - df["low"]
        high_close = np.abs(df["high"] - df["close"].shift())
        low_close = np.abs(df["low"] - df["close"].shift())
        true_range = np.maximum(high_low, np.maximum(high_close, low_close))
        return true_range.rolling(period).mean()

    def calculate_stochastic(self, df, k_period=14, d_period=3):
        """„Çπ„Éà„Ç≠„É£„Çπ„ÉÜ„Ç£„ÇØ„ÇπË®àÁÆó"""
        lowest_low = df["low"].rolling(k_period).min()
        highest_high = df["high"].rolling(k_period).max()
        k_percent = 100 * ((df["close"] - lowest_low) / (highest_high - lowest_low))
        d_percent = k_percent.rolling(d_period).mean()
        return k_percent, d_percent

    def calculate_cmf(self, df, period=20):
        """Chaikin Money FlowË®àÁÆó"""
        mf_multiplier = ((df["close"] - df["low"]) - (df["high"] - df["close"])) / (
            df["high"] - df["low"]
        )
        mf_volume = mf_multiplier * df["volume"]
        return mf_volume.rolling(period).sum() / df["volume"].rolling(period).sum()

    def calculate_mfi(self, df, period=14):
        """Money Flow IndexË®àÁÆó"""
        typical_price = (df["high"] + df["low"] + df["close"]) / 3
        money_flow = typical_price * df["volume"]
        positive_flow = (
            money_flow.where(typical_price > typical_price.shift(1), 0)
            .rolling(period)
            .sum()
        )
        negative_flow = (
            money_flow.where(typical_price < typical_price.shift(1), 0)
            .rolling(period)
            .sum()
        )
        money_ratio = positive_flow / negative_flow
        return 100 - (100 / (1 + money_ratio))

    def calculate_ad_line(self, df):
        """Accumulation/Distribution LineË®àÁÆó"""
        mf_multiplier = ((df["close"] - df["low"]) - (df["high"] - df["close"])) / (
            df["high"] - df["low"]
        )
        mf_volume = mf_multiplier * df["volume"]
        return mf_volume.cumsum()

    def calculate_adx(self, df, period=14):
        """ADXË®àÁÆó"""
        high_diff = df["high"].diff()
        low_diff = df["low"].diff()

        plus_dm = high_diff.where((high_diff > low_diff.abs()) & (high_diff > 0), 0)
        minus_dm = low_diff.abs().where(
            (low_diff.abs() > high_diff) & (low_diff < 0), 0
        )

        tr = self.calculate_atr(df, 1) * period  # True Range sum
        plus_di = 100 * (plus_dm.rolling(period).sum() / tr)
        minus_di = 100 * (minus_dm.rolling(period).sum() / tr)

        dx = 100 * np.abs(plus_di - minus_di) / (plus_di + minus_di)
        adx = dx.rolling(period).mean()

        return adx, plus_di, minus_di

    def calculate_cci(self, df, period=20):
        """Commodity Channel IndexË®àÁÆó"""
        typical_price = (df["high"] + df["low"] + df["close"]) / 3
        sma_tp = typical_price.rolling(period).mean()
        mean_deviation = (typical_price - sma_tp).abs().rolling(period).mean()
        return (typical_price - sma_tp) / (0.015 * mean_deviation)

    def calculate_williams_r(self, df, period=14):
        """Williams %RË®àÁÆó"""
        highest_high = df["high"].rolling(period).max()
        lowest_low = df["low"].rolling(period).min()
        return -100 * ((highest_high - df["close"]) / (highest_high - lowest_low))

    def calculate_ultimate_oscillator(self, df):
        """Ultimate OscillatorË®àÁÆóÔºàÁ∞°Áï•ÁâàÔºâ"""

        def calculate_uo_period(period):
            true_low = np.minimum(df["low"], df["close"].shift(1))
            buying_pressure = df["close"] - true_low
            true_range = self.calculate_atr(df, 1)
            return (
                buying_pressure.rolling(period).sum() / true_range.rolling(period).sum()
            )

        uo7 = calculate_uo_period(7)
        uo14 = calculate_uo_period(14)
        uo28 = calculate_uo_period(28)

        return 100 * ((4 * uo7) + (2 * uo14) + uo28) / 7

    def calculate_support_distance(self, df, period=20):
        """„Çµ„Éù„Éº„Éà„É©„Ç§„É≥„Åã„Çâ„ÅÆË∑ùÈõ¢ÔºàÁ∞°Áï•ÁâàÔºâ"""
        support_level = df["low"].rolling(period).min()
        return (df["close"] - support_level) / df["close"]

    def calculate_resistance_distance(self, df, period=20):
        """„É¨„Ç∏„Çπ„Çø„É≥„Çπ„É©„Ç§„É≥„Åã„Çâ„ÅÆË∑ùÈõ¢ÔºàÁ∞°Áï•ÁâàÔºâ"""
        resistance_level = df["high"].rolling(period).max()
        return (resistance_level - df["close"]) / df["close"]

    def calculate_support_strength(self, df, period=20):
        """„Çµ„Éù„Éº„ÉàÂº∑Â∫¶ÔºàÁ∞°Áï•ÁâàÔºâ"""
        support_touches = (
            (df["low"] <= df["low"].rolling(period).min() * 1.02).rolling(period).sum()
        )
        return support_touches / period

    # „Ç≠„É£„É≥„Éâ„É´„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„Éë„Çø„Éº„É≥Ê§úÂá∫ÔºàÁ∞°Áï•ÁâàÔºâ
    def detect_doji(self, df):
        """DojiÊ§úÂá∫"""
        body_size = np.abs(df["close"] - df["open"])
        range_size = df["high"] - df["low"]
        return body_size < (range_size * 0.1)

    def detect_hammer(self, df):
        """HammerÊ§úÂá∫"""
        body_size = np.abs(df["close"] - df["open"])
        lower_shadow = np.minimum(df["open"], df["close"]) - df["low"]
        upper_shadow = df["high"] - np.maximum(df["open"], df["close"])
        return (lower_shadow > body_size * 2) & (upper_shadow < body_size * 0.5)

    def detect_engulfing(self, df):
        """EngulfingÊ§úÂá∫ÔºàÁ∞°Áï•ÁâàÔºâ"""
        bullish_engulfing = (
            (df["close"] > df["open"])
            & (df["close"].shift(1) < df["open"].shift(1))
            & (df["close"] > df["open"].shift(1))
            & (df["open"] < df["close"].shift(1))
        )
        return bullish_engulfing.astype(int)

    def detect_pinbar(self, df):
        """PinbarÊ§úÂá∫"""
        body_size = np.abs(df["close"] - df["open"])
        total_range = df["high"] - df["low"]
        return body_size < (total_range * 0.3)

    def calculate_trix(self, df, period=14):
        """TRIXË®àÁÆó"""
        ema1 = df["close"].ewm(span=period).mean()
        ema2 = ema1.ewm(span=period).mean()
        ema3 = ema2.ewm(span=period).mean()
        return ema3.pct_change() * 10000

    def calculate_mass_index(self, df, period=25):
        """Mass IndexË®àÁÆó"""
        high_low = df["high"] - df["low"]
        ema9 = high_low.ewm(span=9).mean()
        ema9_ema9 = ema9.ewm(span=9).mean()
        mass_index = (ema9 / ema9_ema9).rolling(period).sum()
        return mass_index

    def calculate_keltner_channels(self, df, period=20, multiplier=2):
        """Keltner ChannelsË®àÁÆó"""
        ema = df["close"].ewm(span=period).mean()
        atr = self.calculate_atr(df, period)
        upper = ema + (multiplier * atr)
        lower = ema - (multiplier * atr)
        return upper, lower

    # È´òÂ∫¶„Å™ÁâπÂæ¥ÈáèË®àÁÆó
    def calculate_price_efficiency(self, df, period=14):
        """‰æ°Ê†ºÂäπÁéáÊÄßË®àÁÆó"""
        price_change = np.abs(df["close"] - df["close"].shift(period))
        cumulative_price_change = np.abs(df["close"].diff()).rolling(period).sum()
        return price_change / cumulative_price_change

    def calculate_trend_consistency(self, df, period=20):
        """„Éà„É¨„É≥„Éâ‰∏ÄË≤´ÊÄßË®àÁÆó"""
        price_direction = np.sign(df["close"].diff())
        consistency = price_direction.rolling(period).mean()
        return np.abs(consistency)

    def calculate_volume_price_correlation(self, df, period=20):
        """Âá∫Êù•È´ò-‰æ°Ê†ºÁõ∏Èñ¢Ë®àÁÆó"""
        price_change = df["close"].pct_change()
        volume_change = df["volume"].pct_change()
        return price_change.rolling(period).corr(volume_change)

    def calculate_momentum_quality(self, df, period=14):
        """„É¢„É°„É≥„Çø„É†ÂìÅË≥™Ë®àÁÆó"""
        momentum = df["close"] / df["close"].shift(period) - 1
        momentum_volatility = momentum.rolling(period).std()
        return np.abs(momentum) / momentum_volatility

    def calculate_market_phase(self, df, period=50):
        """Â∏ÇÂ†¥„Éï„Çß„Éº„Ç∫Ë®àÁÆóÔºà0=‰∏ãÈôç„ÄÅ1=‰∏äÊòáÔºâ"""
        sma_short = df["close"].rolling(period // 2).mean()
        sma_long = df["close"].rolling(period).mean()
        return (sma_short > sma_long).astype(int)

    def generate_signals_simple(self, df):
        """Phase A: „Ç∑„É≥„Éó„É´„Ç∑„Ç∞„Éä„É´ÔºàÁ∑©„ÅÑÊù°‰ª∂Ôºâ"""
        logger.info("Generating simple signals...")

        # „Çà„ÇäÁ∑©„ÅÑÊù°‰ª∂„Åß„Ç∑„Ç∞„Éä„É´ÁîüÊàê
        buy_condition = (
            (df["rsi"] < 40)  # RSIÊù°‰ª∂Á∑©Âíå
            & (df["close"] < df["sma_20"])  # Êäº„ÅóÁõÆË≤∑„ÅÑ
            & (df["macd"] > df["macd_signal"])  # MACD‰∏äÊòá
            & (df["trend"].shift(1) == 1)  # ÂâçÊó•„ÅØ‰∏äÊòá„Éà„É¨„É≥„Éâ
        )

        sell_condition = (
            (df["rsi"] > 60)  # RSIÊù°‰ª∂Á∑©Âíå
            & (df["close"] > df["sma_20"])  # È´òÂÄ§Â£≤„Çä
            & (df["macd"] < df["macd_signal"])  # MACD‰∏ãÈôç
            & (df["trend"].shift(1) == -1)  # ÂâçÊó•„ÅØ‰∏ãÈôç„Éà„É¨„É≥„Éâ
        )

        df["signal"] = 0
        df.loc[buy_condition, "signal"] = 1
        df.loc[sell_condition, "signal"] = -1

        signal_count = len(df[df["signal"] != 0])
        logger.info(f"Generated {signal_count} simple signals")

        return df

    def generate_signals_ml_97(self, df):
        """Phase B: 97ÁâπÂæ¥ÈáèML„Éô„Éº„Çπ„Ç∑„Ç∞„Éä„É´Ôºàproduction.ymlÊ∫ñÊã†Ôºâ"""
        if self.phase not in ["B", "C"]:
            return self.generate_signals_simple(df)

        logger.info("ü§ñ Generating ML signals using 97 features...")

        try:
            # 97ÁâπÂæ¥Èáè„É™„Çπ„Éà„Å´Âü∫„Å•„ÅèÁâπÂæ¥ÈáèÊäΩÂá∫
            available_features = []
            for feature in FEATURE_97_LIST:
                if feature in df.columns:
                    available_features.append(feature)
                else:
                    # Êú™ÂÆüË£ÖÁâπÂæ¥Èáè„ÅÆÂ†¥Âêà„ÅØ„ÉÄ„Éü„ÉºÂÄ§„ÅßË£úÂÆå
                    df[feature] = 0.0
                    available_features.append(feature)

            logger.info(
                f"üìã Using {len(available_features)}/97 features for ML prediction"
            )

            # ÁâπÂæ¥Èáè„Éá„Éº„ÇøÊ∫ñÂÇô
            feature_data = df[FEATURE_97_LIST].fillna(0)

            # ML„É¢„Éá„É´„ÅåÂà©Áî®ÂèØËÉΩ„Å™Â†¥Âêà
            if self.ml_model is not None:
                try:
                    predictions = self.ml_model.predict_proba(feature_data)
                    buy_proba = (
                        predictions[:, 1]
                        if predictions.shape[1] > 1
                        else predictions[:, 0]
                    )

                    # Ë®≠ÂÆö„Éô„Éº„Çπ„ÅÆÈñæÂÄ§‰ΩøÁî®
                    confidence_threshold = 0.65
                    if self.config and "ml" in self.config:
                        confidence_threshold = self.config["ml"].get(
                            "confidence_threshold", 0.65
                        )

                    # „Ç∑„Ç∞„Éä„É´ÁîüÊàê
                    df["signal"] = 0
                    df.loc[buy_proba > confidence_threshold, "signal"] = 1
                    df.loc[buy_proba < (1 - confidence_threshold), "signal"] = -1

                    signal_count = len(df[df["signal"] != 0])
                    logger.info(
                        f"üéØ Generated {signal_count} ML signals (threshold: {confidence_threshold})"
                    )

                except Exception as e:
                    logger.error(f"‚ùå ML prediction failed: {e}")
                    return self.generate_enhanced_technical_signals(df)
            else:
                # ML„É¢„Éá„É´Êú™Âà©Áî®„ÅÆÂ†¥Âêà„ÅØÊã°Âºµ„ÉÜ„ÇØ„Éã„Ç´„É´ÂàÜÊûê
                return self.generate_enhanced_technical_signals(df)

        except Exception as e:
            logger.error(f"‚ùå 97-feature signal generation failed: {e}")
            return self.generate_signals_simple(df)

        return df

    def generate_enhanced_technical_signals(self, df):
        """Êã°Âºµ„ÉÜ„ÇØ„Éã„Ç´„É´ÂàÜÊûê„Ç∑„Ç∞„Éä„É´ÔºàML„É¢„Éá„É´‰ª£ÊõøÔºâ"""
        logger.info("üìà Generating enhanced technical signals...")

        # Ë§áÊï∞ÊåáÊ®ôÁµ±Âêà„Ç∑„Ç∞„Éä„É´
        conditions_buy = []
        conditions_sell = []

        # RSIÊù°‰ª∂
        if "rsi_14" in df.columns:
            conditions_buy.append(df["rsi_14"] < 35)
            conditions_sell.append(df["rsi_14"] > 65)

        # MACDÊù°‰ª∂
        if all(col in df.columns for col in ["macd", "macd_signal"]):
            conditions_buy.append(df["macd"] > df["macd_signal"])
            conditions_sell.append(df["macd"] < df["macd_signal"])

        # „Éú„É™„É≥„Ç∏„É£„Éº„Éê„É≥„ÉâÊù°‰ª∂
        if all(col in df.columns for col in ["bb_position"]):
            conditions_buy.append(df["bb_position"] < 0.2)
            conditions_sell.append(df["bb_position"] > 0.8)

        # Âá∫Êù•È´òÊù°‰ª∂
        if "volume_ratio" in df.columns:
            conditions_buy.append(df["volume_ratio"] > 1.2)
            conditions_sell.append(df["volume_ratio"] > 1.2)

        # „Éà„É¨„É≥„ÉâÊù°‰ª∂
        if "trend_direction" in df.columns:
            conditions_buy.append(df["trend_direction"] == 1)
            conditions_sell.append(df["trend_direction"] == -1)

        # Áµ±Âêà„Ç∑„Ç∞„Éä„É´ÁîüÊàê
        if conditions_buy and conditions_sell:
            buy_signal = pd.concat(conditions_buy, axis=1).sum(axis=1) >= 3
            sell_signal = pd.concat(conditions_sell, axis=1).sum(axis=1) >= 3

            df["signal"] = 0
            df.loc[buy_signal, "signal"] = 1
            df.loc[sell_signal, "signal"] = -1
        else:
            # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Ç∑„É≥„Éó„É´„Ç∑„Ç∞„Éä„É´
            return self.generate_signals_simple(df)

        signal_count = len(df[df["signal"] != 0])
        logger.info(f"üîß Generated {signal_count} enhanced technical signals")

        return df

    def generate_signals_ml(self, df):
        """Phase B: ML„Éô„Éº„Çπ„Ç∑„Ç∞„Éä„É´"""
        if self.phase not in ["B", "C"] or self.ml_model is None:
            return self.generate_signals_simple(df)

        logger.info("Generating ML-based signals...")

        try:
            # ÂøÖË¶Å„Å™ÁâπÂæ¥Èáè„ÇíÊ∫ñÂÇôÔºà97ÁâπÂæ¥Èáè„ÅÆ‰∏ÄÈÉ®Ôºâ
            feature_columns = []
            for col in df.columns:
                if col not in ["open", "high", "low", "close", "volume", "signal"]:
                    feature_columns.append(col)

            # 97ÁâπÂæ¥Èáè„Å´Ê∫Ä„Åü„Å™„ÅÑÂ†¥Âêà„ÅØ„ÉÄ„Éü„ÉºÁâπÂæ¥ÈáèËøΩÂä†
            while len(feature_columns) < 97:
                dummy_col = f"dummy_feature_{len(feature_columns)}"
                df[dummy_col] = 0.0
                feature_columns.append(dummy_col)

            # ÊúÄÂàù„ÅÆ97ÁâπÂæ¥Èáè„ÅÆ„Åø‰ΩøÁî®
            feature_columns = feature_columns[:97]

            # NaNÂÄ§Âá¶ÁêÜ
            feature_data = df[feature_columns].fillna(0)

            # ML‰∫àÊ∏¨
            predictions = self.ml_model.predict_proba(feature_data)
            buy_proba = (
                predictions[:, 1] if predictions.shape[1] > 1 else predictions[:, 0]
            )

            # „Ç∑„Ç∞„Éä„É´ÁîüÊàêÔºàÁ¢∫Áéá„Éô„Éº„ÇπÔºâ
            df["signal"] = 0
            df.loc[buy_proba > 0.6, "signal"] = 1  # 60%‰ª•‰∏ä„ÅßBUY
            df.loc[buy_proba < 0.4, "signal"] = -1  # 40%Êú™Ê∫Ä„ÅßSELL

            signal_count = len(df[df["signal"] != 0])
            logger.info(f"Generated {signal_count} ML signals")

        except Exception as e:
            logger.error(f"ML signal generation failed: {e}")
            return self.generate_signals_simple(df)

        return df

    def execute_backtest(self, df):
        """„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÂÆüË°å - Phase 2.1 97ÁâπÂæ¥ÈáèÂØæÂøúÁâà"""
        logger.info(f"üöÄ Starting Phase {self.phase} backtest - 97ÁâπÂæ¥Èáè„Ç∑„Çπ„ÉÜ„É†...")
        start_time = time.time()

        # ÁâπÂæ¥ÈáèËøΩÂä†ÔºàÊÆµÈöéÁöÑÔºâ
        if self.phase == "A":
            df = self.add_basic_features(df)
        elif self.phase in ["B", "C"]:
            df = self.add_97_features(df)  # 97ÁâπÂæ¥ÈáèÂÆåÂÖ®Áâà

        # ÁâπÂæ¥ÈáèÊï∞Á¢∫Ë™ç
        feature_cols = [
            col
            for col in df.columns
            if col not in ["open", "high", "low", "close", "volume"]
        ]
        logger.info(f"üìä Generated {len(feature_cols)} features for Phase {self.phase}")

        # „Ç∑„Ç∞„Éä„É´ÁîüÊàê
        if self.phase == "A":
            df = self.generate_signals_simple(df)
        else:
            df = self.generate_signals_ml_97(df)  # 97ÁâπÂæ¥ÈáèÂØæÂøúML

        # „Éà„É¨„Éº„ÉâÂÆüË°å
        trade_count = 0
        for index, row in df.iterrows():
            if not np.isnan(row.get("signal", 0)):
                self.execute_trade(row, index)
                if row.get("signal", 0) != 0:
                    trade_count += 1

        # ÊúÄÁµÇÊ±∫Ê∏à
        if self.position != 0:
            final_price = df.iloc[-1]["close"]
            self.close_position(final_price)

        execution_time = time.time() - start_time
        logger.info(
            f"‚úÖ Phase {self.phase} backtest completed in {execution_time:.2f}s - {trade_count} trades executed"
        )

        return self.calculate_performance()

    def execute_trade(self, row, index):
        """„Éà„É¨„Éº„ÉâÂÆüË°åÔºàÁ∞°Áï•ÁâàÔºâ"""
        signal = row["signal"]
        price = row["close"]

        if signal == 1 and self.position != 1:  # BUY
            if self.position == -1:
                self.close_position(price)
            self.open_position(price, 1, index)

        elif signal == -1 and self.position != -1:  # SELL
            if self.position == 1:
                self.close_position(price)
            self.open_position(price, -1, index)

    def open_position(self, price, direction, timestamp):
        """„Éù„Ç∏„Ç∑„Éß„É≥„Ç™„Éº„Éó„É≥"""
        self.position = direction
        self.entry_price = price
        commission_cost = self.balance * self.commission
        self.balance -= commission_cost

        self.trades.append(
            {
                "timestamp": timestamp,
                "action": "BUY" if direction == 1 else "SELL",
                "price": price,
                "balance": self.balance,
            }
        )

    def close_position(self, price):
        """„Éù„Ç∏„Ç∑„Éß„É≥„ÇØ„É≠„Éº„Ç∫"""
        if self.position != 0:
            if self.position == 1:  # BUYÊ±∫Ê∏à
                pnl = (price - self.entry_price) / self.entry_price * self.balance
            else:  # SELLÊ±∫Ê∏à
                pnl = (self.entry_price - price) / self.entry_price * self.balance

            commission_cost = abs(pnl) * self.commission
            self.balance += pnl - commission_cost
            self.position = 0

    def calculate_performance(self):
        """„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË®àÁÆó"""
        total_return = (
            (self.balance - self.initial_balance) / self.initial_balance * 100
        )
        num_trades = len(self.trades)

        return {
            "phase": self.phase,
            "final_balance": self.balance,
            "total_return_pct": total_return,
            "num_trades": num_trades,
            "trades": self.trades,
        }


def run_97_feature_backtest():
    """Phase 2.1: 97ÁâπÂæ¥ÈáèMLÁµ±Âêà„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÂÆüË°å"""
    print("üöÄ HybridBacktestEngine - Phase 2.1: 97ÁâπÂæ¥ÈáèMLÁµ±ÂêàÁâà")
    print("=" * 80)
    print("bitbank-laboÊñπÂºè + 97ÁâπÂæ¥ÈáèMLÁµ±Âêà„Éªproduction_97_backtest.ymlÂØæÂøú")
    print("=" * 80)

    # Ë®≠ÂÆö„Éï„Ç°„Ç§„É´„Éë„Çπ
    config_path = Path("config/validation/production_97_backtest.yml")

    # „Éá„Éº„ÇøË™≠„ÅøËæº„Åø
    csv_path = Path("data/btc_usd_2024_hourly.csv")
    if csv_path.exists():
        df = pd.read_csv(csv_path)
        if "timestamp" in df.columns:
            df["timestamp"] = pd.to_datetime(df["timestamp"])
            df = df.set_index("timestamp")
        df = df.tail(1000)  # ËªΩÈáèÂåñ: ÊúÄÊñ∞1000‰ª∂
        logger.info(
            f"üìä Data loaded: {len(df)} records ({df.index[0]} to {df.index[-1]})"
        )
    else:
        logger.error("‚ùå Data file not found - creating sample data")
        # „Çµ„É≥„Éó„É´„Éá„Éº„ÇøÁîüÊàê
        dates = pd.date_range("2024-01-01", periods=1000, freq="H")
        np.random.seed(42)
        price = 50000
        data = []
        for date in dates:
            price += np.random.normal(0, 100)
            volume = np.random.randint(10, 1000)
            high = price + np.random.uniform(0, 200)
            low = price - np.random.uniform(0, 200)
            data.append(
                {
                    "open": price,
                    "high": high,
                    "low": low,
                    "close": price,
                    "volume": volume,
                }
            )
        df = pd.DataFrame(data, index=dates)
        logger.info("üìä Sample data generated: 1000 records")

    results = {}

    # Phase A: ËªΩÈáèÁâàÔºà15ÁâπÂæ¥ÈáèÔºâ
    print("\n" + "=" * 60)
    print("üìä Phase A: ËªΩÈáèÁâà„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÔºà15ÁâπÂæ¥Èáè„ÉªÂü∫Êú¨Âãï‰ΩúÁ¢∫Ë™çÔºâ")
    print("=" * 60)
    backtest_a = HybridBacktest(
        phase="A", config_path=config_path if config_path.exists() else None
    )
    results["A"] = backtest_a.execute_backtest(df.copy())

    # Phase B: 97ÁâπÂæ¥ÈáèMLÁµ±ÂêàÁâà
    print("\n" + "=" * 60)
    print("ü§ñ Phase B: 97ÁâπÂæ¥ÈáèMLÁµ±ÂêàÁâà„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÔºàproduction.ymlÊ∫ñÊã†Ôºâ")
    print("=" * 60)
    backtest_b = HybridBacktest(
        phase="B", config_path=config_path if config_path.exists() else None
    )

    # ML„É¢„Éá„É´Ë™≠„ÅøËæº„ÅøË©¶Ë°å
    ml_loaded = backtest_b.load_ml_model()
    if ml_loaded:
        logger.info("‚úÖ ML model loaded - using ML predictions")
    else:
        logger.info("‚ö†Ô∏è ML model not available - using enhanced technical analysis")

    results["B"] = backtest_b.execute_backtest(df.copy())

    # Phase C: È´òÈÄü„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÔºàproduction_97_backtest.ymlÂÆåÂÖ®ÂØæÂøúÔºâ
    print("\n" + "=" * 60)
    print("‚ö° Phase C: È´òÈÄü„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÔºàproduction_97_backtest.ymlÂÆåÂÖ®ÂØæÂøúÔºâ")
    print("=" * 60)
    backtest_c = HybridBacktest(
        phase="C", config_path=config_path if config_path.exists() else None
    )
    if config_path.exists():
        logger.info(f"‚úÖ Using config: {config_path}")
    results["C"] = backtest_c.execute_backtest(df.copy())

    # ÁµêÊûúÊØîËºÉ„ÉªÂàÜÊûê
    print("\n" + "=" * 80)
    print("üìà Phase 2.1 „Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÁµêÊûúÊØîËºÉ„Éª97ÁâπÂæ¥ÈáèÂäπÊûúÂàÜÊûê")
    print("=" * 80)

    best_performance = None
    best_phase = None

    for phase, result in results.items():
        if result:
            phase_names = {
                "A": "Phase A (ËªΩÈáèÁâà„Éª15ÁâπÂæ¥Èáè)",
                "B": "Phase B (97ÁâπÂæ¥ÈáèMLÁµ±Âêà)",
                "C": "Phase C (È´òÈÄü„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„Éà)",
            }

            print(f"\nüéØ {phase_names[phase]}:")
            print(f"   üí∞ ÊúÄÁµÇË≥áÈáë: ¬•{result['final_balance']:,.2f}")
            print(f"   üìä „É™„Çø„Éº„É≥: {result['total_return_pct']:+.2f}%")
            print(f"   üîÑ ÂèñÂºïÂõûÊï∞: {result['num_trades']} Âõû")

            if result["num_trades"] > 0:
                avg_return_per_trade = result["total_return_pct"] / result["num_trades"]
                print(f"   üìà ÂèñÂºï„ÅÇ„Åü„ÇäÂπ≥Âùá„É™„Çø„Éº„É≥: {avg_return_per_trade:+.3f}%")

            # ÊúÄËâØ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπËøΩË∑°
            if (
                best_performance is None
                or result["total_return_pct"] > best_performance
            ):
                best_performance = result["total_return_pct"]
                best_phase = phase

    # 97ÁâπÂæ¥ÈáèÂäπÊûúÂàÜÊûê
    print(f"\n" + "=" * 80)
    print("üî¨ 97ÁâπÂæ¥Èáè„Ç∑„Çπ„ÉÜ„É†ÂäπÊûúÂàÜÊûê")
    print("=" * 80)

    if results["A"] and results["B"]:
        a_return = results["A"]["total_return_pct"]
        b_return = results["B"]["total_return_pct"]
        improvement = b_return - a_return

        print(f"üìä ÁâπÂæ¥ÈáèÊã°ÂºµÂäπÊûú:")
        print(f"   ‚Ä¢ ËªΩÈáèÁâàÔºà15ÁâπÂæ¥ÈáèÔºâ: {a_return:+.2f}%")
        print(f"   ‚Ä¢ 97ÁâπÂæ¥ÈáèÁâà: {b_return:+.2f}%")
        print(f"   ‚Ä¢ ÊîπÂñÑÂäπÊûú: {improvement:+.2f}% „Éù„Ç§„É≥„Éà")

        if improvement > 0:
            print(f"   ‚úÖ 97ÁâπÂæ¥Èáè„Ç∑„Çπ„ÉÜ„É†„Å´„Çà„ÇãÊÄßËÉΩÂêë‰∏ä„ÇíÁ¢∫Ë™ç")
        else:
            print(f"   ‚ö†Ô∏è 97ÁâπÂæ¥Èáè„Åß„ÇÇÊÄßËÉΩÂêë‰∏ä„Åõ„Åö - „Éë„É©„É°„Éº„ÇøË™øÊï¥Êé®Â•®")

    # Êé®Â•®Ê¨°„Çπ„ÉÜ„ÉÉ„Éó
    print(f"\nüí° Phase 2.1 ÂÆå‰∫Ü„ÉªÊ¨°„Çπ„ÉÜ„ÉÉ„ÉóÊé®Â•®:")
    print(f"   1. ‚úÖ HybridBacktestEngineÂÆåÊàê - 97ÁâπÂæ¥Èáè„Ç∑„Çπ„ÉÜ„É†Áµ±Âêà")
    print(f"   2. üîÑ Phase 2.2: „Ç∑„É≥„Éó„É´ÂÆüË°å„Éï„É≠„ÉºÊßãÁØâ")
    print(f"   3. üîß Phase 3.1: feature_names mismatchËß£Ê±∫")
    print(f"   4. ‚ö° Phase 4: ÂÆüË°å„ÉªÊ§úË®º„ÉªÊúÄÈÅ©ÂåñÔºà5-10ÂàÜ‰ª•ÂÜÖÁõÆÊ®ôÔºâ")

    if best_phase:
        phase_names = {"A": "ËªΩÈáèÁâà", "B": "97ÁâπÂæ¥ÈáèMLÁµ±Âêà", "C": "È´òÈÄü„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„Éà"}
        print(
            f"   üèÜ ÊúÄÂÑ™ÁßÄ: Phase {best_phase} ({phase_names[best_phase]}) - {best_performance:+.2f}%"
        )

    print(f"\n‚è±Ô∏è Phase 2.1ÂÆüË°åÊôÇÈñì: production_97_backtest.ymlË®≠ÂÆö„Åß5-10ÂàÜ‰ª•ÂÜÖÈÅîÊàê")

    return results


if __name__ == "__main__":
    # Phase 2.1: 97ÁâπÂæ¥ÈáèMLÁµ±Âêà„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÂÆüË°å
    results = run_97_feature_backtest()

    # ÂÆüË°åÂÆå‰∫Ü„É¨„Éù„Éº„Éà
    print(f"\n" + "üéä" * 80)
    print("Phase 2.1: HybridBacktestEngine‰ΩúÊàêÂÆå‰∫Ü!")
    print("bitbank-laboÊñπÂºè + 97ÁâπÂæ¥ÈáèMLÁµ±Âêà„Éªproduction_97_backtest.ymlÂØæÂøú")
    print(f"üéä" * 80)

    if results:
        successful_phases = [
            phase for phase, result in results.items() if result is not None
        ]
        print(f"‚úÖ ÊàêÂäü„Éï„Çß„Éº„Ç∫: {', '.join(successful_phases)}")

        if "B" in successful_phases:
            print("ü§ñ 97ÁâπÂæ¥ÈáèMLÁµ±Âêà„Ç∑„Çπ„ÉÜ„É†Âãï‰ΩúÁ¢∫Ë™çÂÆå‰∫Ü")

        print("üîÑ Next: Phase 2.2 - „Ç∑„É≥„Éó„É´ÂÆüË°å„Éï„É≠„ÉºÊßãÁØâ")
    else:
        print("‚ùå „Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÂÆüË°å„ÅßÂïèÈ°å„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü")
