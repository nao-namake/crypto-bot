"""
ç‰¹å¾´é‡é †åºç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
Phase 2: 97ç‰¹å¾´é‡æœ€é©åŒ–ã‚·ã‚¹ãƒ†ãƒ å¯¾å¿œ

ç›®çš„:
- XGBoost/RandomForestã®feature_names mismatchã‚¨ãƒ©ãƒ¼è§£æ±º
- 97ç‰¹å¾´é‡ã®æ±ºå®šè«–çš„é †åºç®¡ç†
- å­¦ç¿’ãƒ»äºˆæ¸¬é–“ã®ä¸€è²«æ€§ä¿è¨¼
"""

import json
import logging
from pathlib import Path
from typing import List, Optional

import pandas as pd

logger = logging.getLogger(__name__)


class FeatureOrderManager:
    """
    ç‰¹å¾´é‡é †åºã®æ±ºå®šè«–çš„ç®¡ç†ã‚¯ãƒ©ã‚¹

    æ©Ÿèƒ½:
    - 97ç‰¹å¾´é‡ã®å›ºå®šé †åºå®šç¾©
    - å­¦ç¿’æ™‚ã®ç‰¹å¾´é‡é †åºè¨˜éŒ²
    - äºˆæ¸¬æ™‚ã®ç‰¹å¾´é‡é †åºæ•´åˆ
    - ç‰¹å¾´é‡é †åºã®æ¤œè¨¼ãƒ»ãƒ­ã‚°å‡ºåŠ›
    """

    # Phase 2: 127â†’97ç‰¹å¾´é‡æœ€é©åŒ–ï¼ˆé‡è¤‡ç‰¹å¾´é‡30å€‹å‰Šé™¤ï¼‰
    FEATURE_ORDER_97 = [
        # åŸºæœ¬OHLCVç‰¹å¾´é‡
        "open",
        "high",
        "low",
        "close",
        "volume",
        # ãƒ©ã‚°ç‰¹å¾´é‡ï¼ˆæœ€é©åŒ–ï¼šé‡è¦ãªé–“éš”ã®ã¿ä¿æŒï¼‰
        "close_lag_1",
        "close_lag_3",
        "volume_lag_1",
        "volume_lag_4",
        "volume_lag_5",
        # ãƒªã‚¿ãƒ¼ãƒ³ç‰¹å¾´é‡ï¼ˆæœ€é©åŒ–ï¼šlog_returnsã‚’å‰Šé™¤ï¼‰
        "returns_1",
        "returns_2",
        "returns_3",
        "returns_5",
        "returns_10",
        # ç§»å‹•å¹³å‡ï¼ˆæœ€é©åŒ–ï¼šEMAã®ã¿ä¿æŒã€SMAå‰Šé™¤ï¼‰
        "ema_5",
        "ema_10",
        "ema_20",
        "ema_50",
        "ema_100",
        "ema_200",
        # ä¾¡æ ¼ä½ç½®
        "price_position_20",
        "price_position_50",
        "price_vs_sma20",
        "bb_position",
        "intraday_position",
        # ãƒœãƒªãƒ³ã‚¸ãƒ£ãƒ¼ãƒãƒ³ãƒ‰
        "bb_upper",
        "bb_middle",
        "bb_lower",
        "bb_width",
        "bb_squeeze",
        # ãƒ¢ãƒ¡ãƒ³ã‚¿ãƒ æŒ‡æ¨™ï¼ˆæœ€é©åŒ–ï¼šRSI_14ã®ã¿ä¿æŒï¼‰
        "rsi_14",
        "rsi_oversold",
        "rsi_overbought",
        "macd",
        "macd_signal",
        "macd_hist",
        "macd_cross_up",
        "macd_cross_down",
        "stoch_k",
        "stoch_d",
        "stoch_oversold",
        "stoch_overbought",
        # ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆæœ€é©åŒ–ï¼šATR_14ã¨volatility_20ã®ã¿ä¿æŒï¼‰
        "atr_14",
        "volatility_20",
        # å‡ºæ¥é«˜æŒ‡æ¨™
        "volume_sma_20",
        "volume_ratio",
        "volume_trend",
        "vwap",
        "vwap_distance",
        "obv",
        "obv_sma",
        "cmf",
        "mfi",
        "ad_line",
        # ãƒˆãƒ¬ãƒ³ãƒ‰æŒ‡æ¨™
        "adx_14",
        "plus_di",
        "minus_di",
        "trend_strength",
        "trend_direction",
        "cci_20",
        "williams_r",
        "ultimate_oscillator",
        "momentum_14",
        # ãƒãƒ¼ã‚±ãƒƒãƒˆæ§‹é€ 
        "support_distance",
        "resistance_distance",
        "support_strength",
        "volume_breakout",
        "price_breakout_up",
        "price_breakout_down",
        # ãƒ­ãƒ¼ã‚½ã‚¯è¶³ãƒ‘ã‚¿ãƒ¼ãƒ³
        "doji",
        "hammer",
        "engulfing",
        "pinbar",
        # çµ±è¨ˆçš„ç‰¹å¾´é‡ï¼ˆæœ€é©åŒ–ï¼šzscore, close_std_10ã®ã¿ä¿æŒï¼‰
        "zscore",
        "close_std_10",
        # æ™‚ç³»åˆ—ç‰¹å¾´é‡ï¼ˆæœ€é©åŒ–ï¼šis_european_sessionå‰Šé™¤ï¼‰
        "hour",
        "day_of_week",
        "is_weekend",
        "is_asian_session",
        "is_us_session",
        # è¿½åŠ ã®æŠ€è¡“æŒ‡æ¨™
        "roc_10",
        "roc_20",
        "trix",
        "mass_index",
        "keltner_upper",
        "keltner_lower",
        "donchian_upper",
        "donchian_lower",
        "ichimoku_conv",
        "ichimoku_base",
        # ãã®ä»–ã®æ´¾ç”Ÿç‰¹å¾´é‡
        "price_efficiency",
        "trend_consistency",
        "volume_price_correlation",
        "volatility_regime",
        "momentum_quality",
        "market_phase",
    ]

    def __init__(self, feature_order_file: Optional[str] = None):
        """
        åˆæœŸåŒ–

        Args:
            feature_order_file: ç‰¹å¾´é‡é †åºã‚’ä¿å­˜/èª­è¾¼ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        """
        self.feature_order_file = feature_order_file or "config/core/feature_order.json"
        self.stored_order: Optional[List[str]] = None

        # ä¿å­˜ã•ã‚ŒãŸé †åºãŒã‚ã‚Œã°èª­ã¿è¾¼ã‚€
        self._load_stored_order()

        logger.info("ğŸ”§ FeatureOrderManager initialized")
        logger.info(f"  - Default order: {len(self.FEATURE_ORDER_97)} features")
        logger.info(f"  - Storage file: {self.feature_order_file}")

    def _load_stored_order(self):
        """ä¿å­˜ã•ã‚ŒãŸç‰¹å¾´é‡é †åºã‚’èª­ã¿è¾¼ã‚€"""
        try:
            path = Path(self.feature_order_file)
            if path.exists():
                with open(path, "r") as f:
                    data = json.load(f)
                    self.stored_order = data.get("feature_order", [])
                    logger.info(
                        f"âœ… Loaded stored feature order: "
                        f"{len(self.stored_order)} features"
                    )
            else:
                logger.info("ğŸ“ No stored feature order found, using default")
        except Exception as e:
            logger.error(f"âŒ Failed to load feature order: {e}")
            self.stored_order = None

    def save_feature_order(self, features: List[str]):
        """
        ç‰¹å¾´é‡é †åºã‚’ä¿å­˜ï¼ˆå­¦ç¿’æ™‚ã«ä½¿ç”¨ï¼‰

        Args:
            features: å­¦ç¿’æ™‚ã®ç‰¹å¾´é‡ãƒªã‚¹ãƒˆ
        """
        # Phase H.29.6: feature_order.jsonå®Œå…¨ä¿è­·ã‚·ã‚¹ãƒ†ãƒ 
        import os
        import sys

        # åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆç’°å¢ƒæ¤œå‡º
        is_test_env = (
            "pytest" in os.environ.get("_", "")
            or "PYTEST_CURRENT_TEST" in os.environ
            or "test" in str(self.feature_order_file).lower()
            or "temp" in str(self.feature_order_file).lower()
            or "/tmp/" in str(self.feature_order_file)
            or "unittest" in sys.modules
            or any("test" in arg.lower() for arg in sys.argv)
            or os.environ.get("CI") == "true"  # CIç’°å¢ƒæ¤œå‡º
        )

        # æœ¬ç•ªfeature_order.jsonå®Œå…¨ä¿è­·
        is_production_file = str(self.feature_order_file) in [
            "feature_order.json",
            "config/core/feature_order.json",
        ]

        if is_production_file and not is_test_env:
            # æœ¬ç•ªç’°å¢ƒã§ã®97ç‰¹å¾´é‡ä»¥å¤–ã®æ›¸ãè¾¼ã¿å®Œå…¨æ‹’å¦
            if len(features) != 97:
                logger.warning(
                    f"ğŸ›¡ï¸ [PROTECTION] Rejected saving {len(features)} features "
                    f"to production feature_order.json (must be exactly 97)"
                )
                return

            # 97ç‰¹å¾´é‡ã®å†…å®¹æ¤œè¨¼
            if not self._validate_97_feature_integrity(features):
                logger.error(
                    "ğŸ›¡ï¸ [PROTECTION] Rejected invalid 97-feature content "
                    "to production feature_order.json"
                )
                return

        # ãƒ†ã‚¹ãƒˆç’°å¢ƒã§ã®å°‘æ•°ç‰¹å¾´é‡ä¿è­·
        if not is_test_env and len(features) < 100:
            logger.warning(
                f"ğŸ›¡ï¸ [PROTECTION] Rejected saving {len(features)} features "
                f"(< 100) to protect production system"
            )
            return
        try:
            data = {
                "feature_order": features,
                "num_features": len(features),
                "timestamp": pd.Timestamp.now().isoformat(),
            }

            with open(self.feature_order_file, "w") as f:
                json.dump(data, f, indent=2)

            self.stored_order = features
            logger.info(f"âœ… Saved feature order: {len(features)} features")

            # é †åºã®æœ€åˆã¨æœ€å¾Œã‚’è¡¨ç¤º
            if len(features) > 10:
                logger.info(f"  First 5: {features[:5]}")
                logger.info(f"  Last 5: {features[-5:]}")
            else:
                logger.info(f"  Features: {features}")

        except Exception as e:
            logger.error(f"âŒ Failed to save feature order: {e}")

    def _validate_97_feature_integrity(self, features: List[str]) -> bool:
        """
        Phase 2: 97ç‰¹å¾´é‡ã‚·ã‚¹ãƒ†ãƒ ã®æ•´åˆæ€§æ¤œè¨¼

        Args:
            features: æ¤œè¨¼ã™ã‚‹ç‰¹å¾´é‡ãƒªã‚¹ãƒˆ

        Returns:
            True if valid 97-feature system
        """
        try:
            # 97ç‰¹å¾´é‡ã®æ•°é‡ãƒã‚§ãƒƒã‚¯
            if len(features) != 97:
                logger.error(f"Feature count mismatch: {len(features)} != 97")
                return False

            # å¿…é ˆç‰¹å¾´é‡ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
            essential_features = [
                "open",
                "high",
                "low",
                "close",
                "volume",
                "rsi_14",
                "ema_20",
                "atr_14",
                "macd",
            ]

            missing_essential = [f for f in essential_features if f not in features]
            if missing_essential:
                logger.error(f"Missing essential features: {missing_essential}")
                return False

            # FEATURE_ORDER_97ã¨ã®é©åˆæ€§ãƒã‚§ãƒƒã‚¯ï¼ˆ80%ä»¥ä¸Šä¸€è‡´ï¼‰
            feature_set = set(features)
            target_set = set(self.FEATURE_ORDER_97)
            overlap = len(feature_set.intersection(target_set))
            overlap_ratio = overlap / 97

            if overlap_ratio < 0.8:  # 80%æœªæº€ã¯æ‹’å¦
                logger.error(
                    f"Feature overlap too low: {overlap_ratio:.2%} "
                    f"(need â‰¥80% with FEATURE_ORDER_97)"
                )
                return False

            logger.info(
                f"âœ… 97-feature integrity validated: {overlap_ratio:.2%} overlap"
            )
            return True

        except Exception as e:
            logger.error(f"Feature integrity validation failed: {e}")
            return False

    def get_consistent_order(self, current_features: List[str]) -> List[str]:
        """
        ä¸€è²«æ€§ã®ã‚ã‚‹ç‰¹å¾´é‡é †åºã‚’å–å¾—

        Args:
            current_features: ç¾åœ¨ã®ç‰¹å¾´é‡ãƒªã‚¹ãƒˆ

        Returns:
            é †åºèª¿æ•´ã•ã‚ŒãŸç‰¹å¾´é‡ãƒªã‚¹ãƒˆ
        """
        # ä¿å­˜ã•ã‚ŒãŸé †åºãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨
        if self.stored_order:
            logger.info(
                f"ğŸ“‹ Using stored feature order ({len(self.stored_order)} features)"
            )
            return self._align_to_stored_order(current_features)

        # ãªã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé †åºã‚’ä½¿ç”¨
        logger.info("ğŸ“‹ Using default feature order")
        return self._align_to_default_order(current_features)

    def _align_to_stored_order(self, current_features: List[str]) -> List[str]:
        """ä¿å­˜ã•ã‚ŒãŸé †åºã«åˆã‚ã›ã¦æ•´åˆ—"""
        current_set = set(current_features)
        stored_set = set(self.stored_order)

        # å…±é€šã®ç‰¹å¾´é‡ã‚’ä¿å­˜ã•ã‚ŒãŸé †åºã§ä¸¦ã¹ã‚‹
        aligned = [f for f in self.stored_order if f in current_set]

        # æ–°ã—ã„ç‰¹å¾´é‡ãŒã‚ã‚Œã°æœ€å¾Œã«è¿½åŠ 
        new_features = current_set - stored_set
        if new_features:
            logger.warning(f"âš ï¸ New features not in stored order: {new_features}")
            aligned.extend(sorted(new_features))

        # ä¸è¶³ã—ã¦ã„ã‚‹ç‰¹å¾´é‡ã‚’è­¦å‘Š
        missing_features = stored_set - current_set
        if missing_features:
            logger.warning(
                f"âš ï¸ Features in stored order but missing now: {missing_features}"
            )

        logger.info(
            f"âœ… Aligned features: {len(aligned)} (was {len(current_features)})"
        )
        return aligned

    def _align_to_default_order(self, current_features: List[str]) -> List[str]:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé †åºã«åˆã‚ã›ã¦æ•´åˆ—"""
        current_set = set(current_features)

        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé †åºã«å­˜åœ¨ã™ã‚‹ç‰¹å¾´é‡ã‚’æŠ½å‡º
        aligned = [f for f in self.FEATURE_ORDER_97 if f in current_set]

        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãªã„ç‰¹å¾´é‡ã‚’è¿½åŠ 
        extra_features = current_set - set(self.FEATURE_ORDER_97)
        if extra_features:
            logger.info(
                f"ğŸ“ Extra features not in default order: {len(extra_features)}"
            )
            aligned.extend(sorted(extra_features))

        logger.info(f"âœ… Aligned to default order: {len(aligned)} features")
        return aligned

    def ensure_column_order(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        DataFrameã®åˆ—é †åºã‚’ä¿è¨¼

        Args:
            df: é †åºèª¿æ•´ã™ã‚‹DataFrame

        Returns:
            åˆ—é †åºãŒèª¿æ•´ã•ã‚ŒãŸDataFrame
        """
        if df.empty:
            return df

        original_columns = list(df.columns)
        ordered_columns = self.get_consistent_order(original_columns)

        # é †åºãŒå¤‰ã‚ã£ãŸå ´åˆã®ã¿ä¸¦ã³æ›¿ãˆ
        if original_columns != ordered_columns:
            logger.info(
                f"ğŸ”„ Reordering columns: "
                f"{len(original_columns)} -> {len(ordered_columns)}"
            )
            df = df[ordered_columns]

            # å¤‰æ›´å†…å®¹ã‚’è¡¨ç¤º
            if len(ordered_columns) <= 20:
                logger.debug(f"  Original: {original_columns[:10]}...")
                logger.debug(f"  Ordered: {ordered_columns[:10]}...")
        else:
            logger.debug("âœ… Column order already consistent")

        return df

    def validate_features(
        self, train_features: List[str], predict_features: List[str]
    ) -> bool:
        """
        å­¦ç¿’æ™‚ã¨äºˆæ¸¬æ™‚ã®ç‰¹å¾´é‡ã‚’æ¤œè¨¼

        Args:
            train_features: å­¦ç¿’æ™‚ã®ç‰¹å¾´é‡
            predict_features: äºˆæ¸¬æ™‚ã®ç‰¹å¾´é‡

        Returns:
            ä¸€è‡´ã—ã¦ã„ã‚Œã°True
        """
        train_set = set(train_features)
        predict_set = set(predict_features)

        # å®Œå…¨ä¸€è‡´ãƒã‚§ãƒƒã‚¯
        if train_set == predict_set and train_features == predict_features:
            logger.info("âœ… Feature validation passed: perfect match")
            return True

        # å·®åˆ†åˆ†æ
        missing_in_predict = train_set - predict_set
        extra_in_predict = predict_set - train_set

        if missing_in_predict:
            logger.error(f"âŒ Features missing in prediction: {missing_in_predict}")
        if extra_in_predict:
            logger.error(f"âŒ Extra features in prediction: {extra_in_predict}")

        # é †åºã®é•ã„ã‚’ãƒã‚§ãƒƒã‚¯
        common_features = train_set & predict_set
        if common_features:
            train_order = [f for f in train_features if f in common_features]
            predict_order = [f for f in predict_features if f in common_features]

            if train_order != predict_order:
                logger.error("âŒ Feature order mismatch detected")
                # æœ€åˆã®ä¸ä¸€è‡´ã‚’è¡¨ç¤º
                for i, (t, p) in enumerate(zip(train_order, predict_order)):
                    if t != p:
                        logger.error(f"  Position {i}: '{t}' vs '{p}'")
                        break

        return False

    # Phase 2: çµ±ä¸€ç‰¹å¾´é‡å®Œå…¨æ€§ä¿è¨¼ã‚·ã‚¹ãƒ†ãƒ 
    def ensure_features_completeness(
        self, df: pd.DataFrame, target_count: int = 97
    ) -> pd.DataFrame:
        """
        æŒ‡å®šã•ã‚ŒãŸç‰¹å¾´é‡æ•°ã®å®Œå…¨æ€§ã‚’ä¿è¨¼ã™ã‚‹çµ±ä¸€ã‚·ã‚¹ãƒ†ãƒ 

        Args:
            df: å…¥åŠ›DataFrame
            target_count: ç›®æ¨™ç‰¹å¾´é‡æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ97ï¼‰

        Returns:
            æ­£ç¢ºã«æŒ‡å®šã•ã‚ŒãŸæ•°ã®ç‰¹å¾´é‡ã‚’æŒã¤DataFrame
        """
        logger.info(
            f"ğŸ” [Phase 2] Starting feature completeness: {len(df.columns)} â†’ {target_count}"
        )

        try:
            # ç¾åœ¨ã®ã‚·ã‚¹ãƒ†ãƒ ã«å¿œã˜ãŸç‰¹å¾´é‡ãƒªã‚¹ãƒˆã‚’å–å¾—
            target_features = (
                self.FEATURE_ORDER_97
                if target_count == 97
                else self.FEATURE_ORDER_97[:target_count]
            )

            # åŸºæœ¬å‡¦ç†
            current_features = set(df.columns)

            # å…±é€šç‰¹å¾´é‡ã‚’é †åºã«å¾“ã£ã¦é¸æŠ
            ordered_features = [f for f in target_features if f in current_features]

            # ä¸è¶³åˆ†ã‚’0ã§è£œå®Œ
            missing_count = target_count - len(ordered_features)
            if missing_count > 0:
                logger.info(f"è£œå®ŒãŒå¿…è¦: {missing_count}ç‰¹å¾´é‡")
                for i in range(missing_count):
                    feature_name = f"auto_fill_{i:03d}"
                    ordered_features.append(feature_name)
                    df[feature_name] = 0.0

            # æ­£ç¢ºãªç‰¹å¾´é‡æ•°ã«èª¿æ•´
            final_features = ordered_features[:target_count]
            result_df = df[final_features].copy()

            logger.info(
                f"âœ… [Phase 2] Feature completeness guaranteed: {len(result_df.columns)} features"
            )
            return result_df

        except Exception as e:
            logger.error(f"âŒ [Phase 2] Feature completeness failed: {e}")
            # ç·Šæ€¥ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            return self._create_fallback_features(df, target_count)

    # 97ç‰¹å¾´é‡ã‚·ã‚¹ãƒ†ãƒ ç”¨ã®ãƒ¡ã‚¤ãƒ³é–¢æ•°
    def ensure_97_features_completeness(self, df: pd.DataFrame) -> pd.DataFrame:
        """97ç‰¹å¾´é‡ã‚·ã‚¹ãƒ†ãƒ ç”¨ã®ãƒ¡ã‚¤ãƒ³é–¢æ•°"""
        return self.ensure_features_completeness(df, target_count=97)

    # Phase 2: 97ç‰¹å¾´é‡ã‚·ã‚¹ãƒ†ãƒ å°‚ç”¨ãƒ¡ã‚½ãƒƒãƒ‰

    def _create_fallback_features(
        self, df: pd.DataFrame, target_count: int
    ) -> pd.DataFrame:
        """ç·Šæ€¥æ™‚ã®ç‰¹å¾´é‡ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆçµ±ä¸€ç‰ˆï¼‰"""
        logger.warning(f"ğŸš¨ Creating emergency fallback with {target_count} features")

        # åŸºæœ¬ç‰¹å¾´é‡ã‚’å–å¾—
        target_features = (
            self.FEATURE_ORDER_97[:target_count]
            if target_count <= 97
            else self.FEATURE_ORDER_97
        )

        # ä¸è¶³åˆ†ã‚’0åŸ‹ã‚ã§ä½œæˆ
        result_df = pd.DataFrame(
            0.0, index=df.index if not df.empty else [0], columns=target_features
        )

        # åˆ©ç”¨å¯èƒ½ãªç‰¹å¾´é‡ã‚’ã‚³ãƒ”ãƒ¼
        for col in df.columns:
            if col in result_df.columns:
                result_df[col] = df[col]

        logger.warning(
            f"ğŸš¨ Emergency fallback created: {len(result_df.columns)} features"
        )
        return result_df

    # 97ç‰¹å¾´é‡å°‚ç”¨ç·Šæ€¥ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

    def _emergency_97_fallback_enhanced(self, df: pd.DataFrame) -> pd.DataFrame:
        """ç·Šæ€¥æ™‚ã®97ç‰¹å¾´é‡ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯"""
        return self._create_fallback_features(df, 97)


# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
_global_feature_order_manager: Optional[FeatureOrderManager] = None


def get_feature_order_manager() -> FeatureOrderManager:
    """ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªç‰¹å¾´é‡é †åºç®¡ç†ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—"""
    global _global_feature_order_manager
    if _global_feature_order_manager is None:
        _global_feature_order_manager = FeatureOrderManager()
    return _global_feature_order_manager
